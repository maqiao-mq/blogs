# 背景

这个用来记录一些不成体系的散装知识点。

# harden

bpf_jit_harden，这个开关的含义：

- 0，不启用 harden
- 1，只给非特权用户启用 harden
- 2，给全部用户启用 harden

这个是用来防止一些攻击的，目前来看，原理是把 eBPF 字节码里面的所有用到的常量，都给替换一下。

比如说原始指令里面的常量是imm，先搞一个随机常量 imm_rnd，然后翻译成：

```
MOV AX, imm_rnd ^ imm
XOR AX, imm_rnd
# 原始指令
```

这样一通操作下来，原始常量就被隐藏掉了。

整体的代码逻辑在 `kernel/bpf/core.c bpf_jit_blind_insn()`里面，这个替换逻辑一般没啥问题，但是坑爹的地方在于，这个替换是O(n^2)的。

逻辑是这样的：

- 外层一个大循环，遍历每条指令，如果有常量，就做一遍转换
- 里面一个小循环，转换出来的指令比原指令多，所以所有涉及到 jmp 一类跳转的指令，全部要改一遍偏移，而且要把其他的原始指令都要memcpy/memmove一遍，以便把新的几条指令给插进来。

所以，如果指令比较多的话，这样的一通翻译会拉低性能。
