# 内存散装知识点记录

## munmap 和 madvise

munmap() 在调用的时候，会尽可能把不用的 page table 给释放掉。

madvise() 有两个flag：

- MADV_DONTNEED，表示用户态不再需要这块内存了，内核在处理的时候，会直接无视内存是否脏页而回收掉。如果后续又去访问这块内存的话，会触发 page fault，然后系统会重新分配一块内存出来。
- MADV_FREE，也和MADV_DONTNEED一样，直接回收，区别是它会lazy free，也就是并不会立即回收，而是在系统内存不够的时候再来回收。而且，期间如果又对这块内存进行了写入动作的话，就会取消回收。

madvise的两个flag，和munamp的区别，在于madvise()目前是不会主动释放page table的，但是貌似upstream有补丁在尝试增加回收page table的能力。

jemalloc和tcmalloc一般会先用 madvise 来回收内存，最后才会用 munmap() 来彻底回收。


# defrag

在 `/sys/kernel/mm/transparent_hugepages/`目录下有2个文件，一个是 `enabled`，一个是 `defrag`。

- `enabled`有3个选项：
  - always，总是尝试使用thp
  - madvise，只有在使用了 madvise 标记的vma，才尝试使用 thp
  - never，不启用 thp
- `defrag` 有类似的选项，但含义完全不同：
  - always，当在page fault一类的上下文分不出大页的时候，就同步等回收、整理，直到有大页为止
  - madvise，只有用madvise标记了的vma在分不出大页的时候，才会同步等，其他情况下fallback到用4k页
  - defer，在分不出大页的时候，先fallback到4k页，然后后台做异步回收、整理，后续再对它进行替换
  - defer+madvise，对madvise标记的区域做always的动作，其他区域做defer的动作
  - never



二者在整个内存的架构体系中生效的位置是不一样的。

在 `handle_mm_fault`的时候，如果判断出现fault 的是匿名内存，且在这个区域可以使用大页的话，就会进入分配大页的路径尝试分配。

在判断是否可用大页的时候，会进入函数 `thp_vma_allowable_order()`，这里就进入到了 `enabled`的逻辑了。如果是配置了always，或者这个vma用madvise标记过，才会允许使用大页。

在进入分配大页的路径 `do_huge_pmd_anonymous_page（）`以后，内核会调用 `vma_alloc_folio()`（老版本是 `vma_alloc_page`)来分配大页，调用该函数需要传递gfp来控制buddy的行为，这个gfp取决于 `vma_thp_gfp_mask()`函数的返回值，里面会结合 `defrag` 的配置来做判断。

在 `vma_alloc_folio（)`里面，根据gfp的行为，可能同步等，可能异步等，但最终返回的结果，可能是拿到了大页，也可能是没拿到。拿到了大页的话，就会把大页给安到pmd上，没拿到就会fallback到用4k页。


`vma_thp_gfp_mask()`这里的逻辑有必要贴一下：

```c
/*
 * always: directly stall for all thp allocations
 * defer: wake kswapd and fail if not immediately available
 * defer+madvise: wake kswapd and directly stall for MADV_HUGEPAGE, otherwise
 *		  fail if not immediately available
 * madvise: directly stall for MADV_HUGEPAGE, otherwise fail if not immediately
 *	    available
 * never: never stall for any thp allocation
 */
gfp_t vma_thp_gfp_mask(struct vm_area_struct *vma)
{
	const bool vma_madvised = vma && (vma->vm_flags & VM_HUGEPAGE);

	/* Always do synchronous compaction */
	if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))
		return GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);

	/* Kick kcompactd and fail quickly */
	if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))
		return GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM;

	/* Synchronous compaction if madvised, otherwise kick kcompactd */
	if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))
		return GFP_TRANSHUGE_LIGHT |
			(vma_madvised ? __GFP_DIRECT_RECLAIM :
					__GFP_KSWAPD_RECLAIM);

	/* Only do synchronous compaction if madvised */
	if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))
		return GFP_TRANSHUGE_LIGHT |
		       (vma_madvised ? __GFP_DIRECT_RECLAIM : 0);

	return GFP_TRANSHUGE_LIGHT;
}
```

总结起来是：

| defrag配置    | vma是否标记 | gfp                                           | 含义                           |
| ------------- | ----------- | --------------------------------------------- | ------------------------------ |
| always        | Y           | GFP_TRANSHUG                                  | 同步compaction                 |
| always        | N           | GFP_TRANSHUG<br />__GFP_NORETRY               |                                |
| defer         | N/A         | GFP_TRANSHUGE_LIGHT<br />__GFP_KSWAPD_RECLAIM | 唤醒kcompactd进行异步整理      |
| defer+madvise | Y           | GFP_TRANSHUGE_LIGHT<br />__GFP_DIRECT_RECLAIM | 同步compaction                 |
|               | N           | GFP_TRANSHUGE_LIGHT<br />__GFP_KSWAPD_RECLAIM | 唤醒kcompactd进行异步整理      |
| madvise       | Y           | GFP_TRANSHUGE_LIGHT<br />__GFP_KSWAPD_RECLAIM | 唤醒kcompactd进行异步整理      |
|               | N           | GFP_TRANSHUGE_LIGHT                           |                                |
| never         | N/A         | GFP_TRANSHUGE_LIGHT                           | 不触发任何整理，分不出来就失败 |

# khugepaged

内核会创建一个 khugepaged 线程，这个线程的逻辑是，不断地扫描mm，遍历并找到其中符合条件的vma，然后判断一个pmd页上的所有page是否可以合并成一个大页，如果可以的话就进行合并和替换。

如果中途有用户动了khugepaged的开关，那么就会将这个 kthread 给关掉。

并不是所有的mm结构体都会被khugepaged扫描，内核维护了一个名为khugepaged_scan的全局链表，里面每个entry 是一个mm_slot，slot里面存的就是mm的信息。

在以下情况下，内核会调用khugepaged_enter_vma() 尝试将 mm 加入到这个链表中：

- vma发生合并
- 调用mmap进行映射
- 匿名内存发生pmd一级的page fault时
- 调用madvise设置MADV_HUGEPAGE标志时

upstream正在引入mthp的功能，核心思想是允许大页的大小是可变的，这在arm上很有用，因为arm支持4k、16k和64k等页面。

# compaction和kswapd

这两个机制是有配合的，所以放在一起来记录。

在 `alloc_page()`的过程中，如果内存不够，就会走到 `__alloc_pages_slowpath()`里面，这个时候就会根据 gfp 来决定是不是要做回收和整理，以及是同步还是异步地做。

```
- __alloc_pages_slowpath
	- wake_all_kswapds
	- __alloc_pages_direct_reclaim
		- __perform_reclaim
			- try_to_free_pages
				- do_try_to_free_pages
					- shrink_zones
						- shrink_node
		- get_page_from_freelist
	- __alloc_pages_direct_compact
```


## kswapd

kswapd 线程是每个node 一个，node在内核里面使用 pg_data_t 来表示的，所以在内核里面会看到很多对它的引用。

kswapd的核心是回收，术语是reclaim，kswapd的逻辑如下：

- 在kswapd 线程没有被stop之前，不断重复 `kswapd_try_to_sleep()`和 `balance_pgdat()`
- `kswapd_try_to_sleep()`的逻辑是，在 kswapd 已经回收了足够的内存的情况下，唤醒 kcompactd 进行内存整理，然后陷入睡眠等待下次唤醒。如果内存不满足要求，就不会陷入睡眠。

kswapd 判断内存是否足够 `(pgdat_balanced())`的逻辑比较复杂。node的每个zone有三个水位线watermark，即min、low、high。`pgdat_balanced()`会对每个zone调用 `zone_watermark_ok_safe（）`来判断 zone 的空闲内存是否符合 high 水位线，但是对于 order 大于 0 的情况下，还得确保至少有一个符合这个 order 的完整 page。order的来源，是某个进程在分配不到内存，唤醒kswapd时传进来的它当时需要的内存的page order。

`balance_pgdat()`负责真正地干活。它主要做的事情：

- 让 lru 的 page 老化一波
- 通过 lru 回收那些作为 cache 的页面
- 通过 shrinker 链表回收各种东西，主要是 slab
- 唤醒 kcompactd 来做一波整理

```
- kswapd
	- balance_pgdat
		- kswapd_age_node
		- kswapd_shrink_node
			- shrink_node
				- shrink_node_memcgs
					- shrink_lruvec
					- shrink_slab
		- wakeup_kcompactd
```


## kcompactd

kcompatcd 线程也是每个node一个。它会陷入一个无限循环，每次循环干两件事：

- 等待一段时间，如果期间被被其他线程唤醒，就开始整理整个node，然后陷入下次等待
- 如果等待超时，则根据compaction_proactiveness的配置判断是否要主动进行整理



整理的逻辑：

node的每个zone，有自己的min、low、high水位线配置。

在整理node的时候，实际上是按照每个zone为单位进行整理的。在整理之前，需要先判定zone是不是符合要整理的条件，判定方式是看当前zone的空闲内存，是否低于min，这个在函数 `compaction_suit_allocation_order()`中可以看到。

在其他alloc_page的上下文中，可能触发直接整理，也就是direct reclaim，这时判定的水位线可能是min、可能是low。

当回收的内存达到high的水位线时，就停止整理。这个可以在todo看到。

```
- kcompactd
	- kcompactd_do_work
```

# ksm

# lru
